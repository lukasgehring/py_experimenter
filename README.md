# PyExperimenter
The PyExperimenter is a tool for the automatic execution of e.g., machine learning experiments. The only requirement for these experiments is that they can be run in a single function. It works with either sqlite or mysql databases.

The execution of different experiment configurations is coordinated by a database and the results are published to the same database.

To execute an experiment with different parameter combinations, the parameters are written into the database. Then multiple threads are started that execute the experiment with the parameter combinations from the database. Lastly, the results are written to the database. Errors that occur during execution are also captured by the written to the database.

## Installation and Configuration
To install the package via pip using the command
```
pip install py-experimenter
```
You can then import the PyExperimenter by using
```
from py_experimenter import PyExperimenter
```

## Workflow
To execute an experiment the following steps are taken
1. The [configuration file](#configuration-file) is read.
2. A database connection is established, and a table (structure defined in the [configuration file](#configuration-file) is created.
3. The [table is filled](#filling-the-database-with-parameter-combinations) with different experiment configurations.
4. An [experiment is started](#execution) with parameter combinations from the database (on different threads).
5. The results of different experiment configurations are written to the database.

Note that multiple experiments can be run at the same time (steps four and five).

## Configuration File
The configuration file is used to define the database credentials, as well as the settings for PyExperimenter.
In addition, the user can define parameter configurations here, which are passed to the executing function during execution.

Each configuration file consists of three sections: `DATABASE`, `PY_EXPERIMENTER`, and `CUSTOM`. Note that the sections `DATABASE` and `PY_EXPERIMENTER` are mandatory while the `CUSTOM` section is optional.
In the following, we will go through these sections and go into more detail about the individual configuration parameters.

#### DATABASE
The database section contains information on the database to which results, potential errors, and meta information of the experiments are written.
```
[DATABASE]
provider=<sqlite or mysql>
database=<databasename>
table=<tablename>
```
You can use `sqlite` as well as `mysql` as a database provider. If you choose to use mysql you need an additional credential file 
```
[CREDENTIALS]
host=<host>
user=<user>
password=<password>
```
that holds further information on the database. Since sqlite utilizes a local database the information is only needed for mysql.

Note that the table is automatically generated by PyExperimenter. However, a different name for both the database and table can be passed at a later time

#### PY_EXPERIMENTER
In this section of the configuration, the experiment is defined.
```
[PY_EXPERIMENTER]
cpu.max = <number_of_cpus>

keyfields = <keyfieldname1>, <keyfieldname2:int(3)>

<keyfieldname1>=A,B,C (example configuration for <keyfieldname1>)
<keyfieldname2>=1,2,3 (example configuration for <keyfieldname2>)

resultfields = <resultfield1>, <resultfield2:LONGTEXT>
```
First, the number of CPUs that you want to use to run the experiments in parallel must be specified. This is a mandatory parameter.

Then a list of keyfields is defined. These are the parameters that are passed to the experiment for execution. This is also mandatory. 

It is optional to also initialize said keyfields. To do this, all possible values are assigned to the respective `keyfield`, separated by commas. The interpretation of these keyfield values is explained [here](#filling-the-database-with-parameter-combinations).

Lastly, a list of resultfields is defined which are filled when the experiment is executed.

Note that both the `keyfields` and the `resultfields` can be assigned a data type.
These must be defined in SQL notation separated from the field name by a colon.
If no data type is explicitly specified, `VARCHAR(255)` is used.

#### CUSTOM
In the last (optional) section you can define your configurations. These are also passed to the experiment. However, while the values given in the keyfields change from experiment to experiment, the custom values are fixed for all experiments.
```
[CUSTOM]
custom.setting1=<value>
custom.setting2=<value>
```

## Connecting to the Database
As mentioned above we can connect to either sqlite or mysql databases.


To establish a connection to the database with sqlite
```python3
PyExperimenter(config_file, table_name, database_name)
```
is called with the following parameters:
- `config_file` refers to the position of the aforementioned configuration file. 
- `table_name` is an optional parameter. If given it overwrites the table name given in the configuration file.
- `database_name` is an optional parameter. If given it overwrites the database name in the configuration file. 

To establish a connection to the database with mysql
```python3
PyExperimenter(config_file, credential_path, table_name, database_name)
```
is called with the parameter `credential_path` as an additional parameter. This path refers to the [credential file](#database) mentioned above.

For both sqlite and mysql, the parameters are then used to connect to the database at `database_name` and create a table with the name `table_name` according to the structure in the configuration file at `config_file`. If there is already a table with the name `table_name` in the database two things can happen:
1. If the table has the same structure nothing happens.
2. If the table has a different structure `TableHasWrongStructureError` is raised.

## Filling the Database with Parameter Combinations
When you want to fill the database with the structure

| parameter 1  | parameter 2  |  ...  |   status    |   machine    | creation date | start date | end date  |   error    |
| :----------: | :----------: | :---: | :---------: | :----------: | :-----------: | :--------: | :-------: | :--------: |
| some value 1 | some value 2 |  ...  | some status | some machine |   some date   | some date  | some date | some error |

(where parameter 1, parameter 2,... are the parameters that are given to the experiment, and the other parameters are meta information) you have three options to do this:

1. Use `fill_table_from_config` ([here](#fill-table-from-configuration))
2. Use `experimenter.fill_table_with_rows` ([here](#fill-table-with-rows))
3. Use `experimenter.fill_table_from_combination`([here](#fill-table-from-combination))


### Fill Table from Configuration
The simplest way to fill the database is using `experimenter.fill_table_from_config`. Here the parameter definitions from the [configuration file](#configuration-file) are utilized.

When the config has the keyfields

```
keyfields = parameter_1, parameter_2
```
and parameter options
```
parameter_1=A,C 
parameter_2=1,2,3 
```
the resulting parameter configurations are the cartesian product of the possible parameters, e.g.,
| parameter_1 | parameter_2 |
| :---------: | :---------: |
|      A      |      1      |
|      A      |      2      |
|      A      |      3      |
|      B      |      1      |
|      B      |      2      |
|      B      |      3      |


### Fill Table with Rows
The second way to fill the database is using `experimenter.fill_table_with_rows`, where one defines all rows in the function call as a list of dictionaries.

```python
experimenter.fill_table_with_rows(
    [
        {'parameter_1': 'A', 'parameter_2': '1'},
        {'parameter_1': 'A', 'parameter_2': '3'},
        {'parameter_1': 'B', 'parameter_2': '2'},
    ]
)
```
therefore leads to:

| parameter_1 | parameter_2 |
| :---------: | :---------: |
|      A      |      1      |
|      A      |      3      |
|      B      |      2      |
### Fill Table from Combination
The last way to fill the database is using `experimenter.fill_table_from_combination`. This is essentially a combination of [the first option](#fill-table-from-configuration), and [the second option](#fill-table-with-rows).

If you have 4 keyfields
```
keyfields=parameter_1, parameter_2, parameter_3, parameter_4
```
to fill and want to write all possible combinations of `parameter_1` and `parameter_2` in the database but only fixed combinations of `parameter_3` and `parameter_4` you can use

```python
experimenter.fill_table_from_combination(
    parameters = {
        'parameter_1': ['A','B'],
        'parameter_2': ['C','D'],
    },
    fixed_parameter_combinations = [
        {
            'parameter_3': 'E',
            'parameter_4': 'F',
        },
        {
            'parameter_3': 'H',
            'parameter_4': 'F',
        },
    ]
)
```
which leads to the cartesian product of the options for parameter 1, options for parameter 2, and combinations of parameters 3 and 4.
| parameter_1 | parameter_2 | parameter_3 | parameter_4 |
| :---------: | :---------: | :---------: | :---------: |
|      A      |      C      |      E      |      F      |
|      A      |      C      |      H      |      F      |
|      A      |      D      |      E      |      F      |
|      A      |      D      |      H      |      F      |
|      B      |      C      |      E      |      F      |
|      B      |      C      |      H      |      F      |
|      B      |      D      |      E      |      F      |
|      B      |      D      |      H      |      F      |



## Execution
To execute experiments you need to define the experiment as a function and then start said function with the experimenter. How this is done is explained in the following two paragraphs.
### Definition of an Experiment
To execute an experiment it needs to be put into a function like
```python
def own_function(keyfields: dict, result_processor: ResultProcessor, custom_fields: dict):
    # run the experiment with the given value for the sin and cos function
    sin_result = sin(parameters['value'])
    cos_result = cos(parameters['value'])

    # write the result in dict with the resultfield as key
    result = {'sin': sin_result, 'cos': cos_result}

    # send the result to the database
    result_processor.process_results(result)
```

that has three keyfields:
1. `parameters`: A dictionary that holds all values given in the table. The keys are the keyfield names defined in the configuration file.
2. `result_processor`: is an object of class `ResultProcessor` which processes the results and writes them to the database. To write one (or multiple) result(s) to the database, create a dictionary of `resultfieldname` and `value` pairs. After that call the `process_results()` method of the `ResultProcessor` and pass the dictionary as an argument to write the results to the database. You can call this method multiple times during the execution of your experiment. Note that you can only write to `resultfields` defined in the [configuration file](#configuration-file). If a dictionary has other keys not defined in the configuration file, the results will not be written to the database.
3. `custom_fields`: A dictionary that holds the values given in [CUSTOM] in the configuration.  Note that this parameter is needed even if you have not set your custom configurations.

### Execution of an Experiment 
To execute the experiment `experimenter.execute(own_function)` needs to be called. It will only run experiments from the database table with the status `created`. This ensures that each experiment is executed only once. After an experiment is started, the status of this experiment is set to `running` and the experiment is started as a new thread. If the experiment is finished without any errors, the status will be set to `done`. However, if errors occur during execution, the status changes to `error`, and the respective error message is written to the database. In both cases, after the termination of one experiment, the next one is executed.
```python
# run all experiments (parameter combinations from the database)
experimenter.execute(own_function)
```
When experiments have been executed, the user can check the database to see if any errors occurred during execution. If this is the case, he can fix the error, delete the experiments where the error occurred from the database and run the `PyExperimenter` again. The deleted experiments will then be automatically recreated and executed. All already successfully executed experiments are not affected by this.

#### Execute Specific Number of Experiments / Execute in Random Order
You can specify a specific number of experiments to execute as well as if the experiments should
be executed in random order. 
```python
experimenter.execute(own_function, max_experiments=10, random_order=True)
```

## Database Entries
All experiments are written to the database, defined in the configuration file. In the following, we will see what such a database table generated by PyExperimenter could look like. The first columns are the keyfields followed by the resultfields, defined in the configuration file. These columns are followed by the `status` and the `machine`, the former indicating the status of the experiment and the latter the id of the machine on which the experiment was run. Note that with the configuration `cpu.max = 1`, the experiments are run on only one machine, so the machine id is identical for each experiment. The status values for the `status` column are as follows:
- `created`: All parameters for the experiment instance are defined, and the instance is ready for execution.
- `running`: The instance of the experiment is currently in execution.
- `done`: The execution of the experiment instance is finished, and the results are written in the database without any errors.
- `error`: An error occurred during execution.

This is followed by the `creation_date`, `start_date` and `end_date` columns, which contain the creation, start and end times. The last column contains the error message of the exercise. If no error occurred, this column contains the entry `NULL`.

### Get Database Entries to Python Code
The PyExperimenter also enables you to get a pandas.DataFrame from the given data
```python
results_table = experimenter.get_results_table()
```
which can be used for further evaluation of the experiment results. For this further evaluation, we recommend the use of the function
```python
results_table.to_latex()
```
with the various keyword arguments descirbed in <a href = "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_latex.html"> the documentation </a>.

Note that the column types of the resulting dataframe are dependent on the types in the sql-table (and therefore on the types in the [configuration file](#configuration-file)).

## Examples
In the `examples` folder, you can find examples for most of the functionality explained here. Note that to execute mysql examples you need to adapt the [configuration file](#configuration-file).
