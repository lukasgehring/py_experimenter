:py:mod:`py_experimenter.experimenter`
======================================

.. py:module:: py_experimenter.experimenter


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   py_experimenter.experimenter.PyExperimenter




.. py:class:: PyExperimenter(experiment_configuration_file_path: str = os.path.join('config', 'configuration.cfg'), database_credential_file_path: str = os.path.join('config', 'database_credentials.cfg'), table_name: str = None, database_name: str = None, name='PyExperimenter')

   Module handling the initialization, execution and collection of experiments and their respective results.

   .. py:method:: set_config_value(section_name: str, key: str, value: str) -> None

      Modifies the experiment configuration so that within the given `section_name` the value of the  property identified by
      the given `key` is overwritten, or created if it was not existing beforehand.

      :param section_name: The name of the section of the experiment configuration in which a value should be set.
      :type section_name: str
      :param key: The name of the key identifying the property within the given section whose value should be set.
      :type key: str
      :param value: The value which should be set to the property identified by the given key in the given section.
      :type value: str
      :raises InvalidConfigError: If the modified configuration either misses, or has invalid information.


   .. py:method:: get_config_value(section_name: str, key: str) -> str

      Returns the value of the property of the experiment configuration identified by the given key. If the `key`
      is not contained within the section, an exception is raised.

      :param section_name: The name of the section containing the property whose value should be returned.
      :type section_name: str
      :param key: The name of the key identifying the property within the given section of the experiment
          configuration of which a value should be returned.
      :type key: str
      :return: The value of the property identified by the given key within the section `section_name` of the
          experiment configuration.
      :rtype: str
      :raises NoOptionError: If the section called `section_name` is not part of the experiment configuration, or
          the `key` is not contained within that section.


   .. py:method:: has_section(section_name: str) -> bool

      Checks whether the experiment configuration contains a section with the given name.

      :param section_name: The name of the section which should be checked for existence.
      :type section_name: str
      :return: True if the section exists, False otherwise.
      :rtype: bool


   .. py:method:: has_option(section_name: str, key: str) -> bool

      Checks whether the experiment configuration contains a property identified by the given 'key' within the
      section called 'section_name'.

      :param section_name: The name of the section of the experiment configuration of which the `key` should be
          checked.
      :type section_name: str
      :param key: The name of the key to check within the given section.
      :type key: str
      :return: True if the given `key` is contained in the experiment configuration within the section called
          `section_name`. False otherwise.
      :rtype: bool


   .. py:method:: _is_valid_configuration(_config: configparser, database_credential_file_path: str = None) -> bool
      :staticmethod:

      Checks whether the given experiment configuration is valid, i.e., it contains all necessary fields, the database provider
      is either mysql or sqlite, and in case of a mysql database provider, that the database credentials are available.

      :param _config: The experiment configuration.
      :type _config: configparser
      :param database_credential_file_path: The path to the database configuration file, i.e., the file defining
          the host, user and password. Defaults to None.
      :type database_credential_file_path: str, optional
      :return: True if the experiment configuration contains all necessary fields.
      :rtype: bool


   .. py:method:: fill_table_from_combination(fixed_parameter_combinations: List[dict] = None, parameters: dict = None) -> None

      Adds rows to the database table based on the given information.

      First the existence of the database table is checked. If it does not exist, the database table is created
      based on the information in the experiment configuration file the `PyExperimenter` has been initialized
      with.

      Afterwards, the database table is filled. To this end, the cartesian product of all `parameters` and the
      `fixed_parameter_combinations` is built, where each combination will make up a row in the database table.
      Note that only rows are added whose parameter combinations do not already exist in the database table.
      For each added row the status is set to 'created'. If any parameter of the combinations (rows) does not
      match the keyfields from the experiment configuration, an error is raised.

      In the following, an example call of this method is given:

      >>> fill_table_from_combination(
      >>>    fixed_parameter_combinations = [ { a:1, a2:2 }, { a:2, a2:4 } ],
      >>>    parameters = { b:[1,2], c:['cat', 'dog']}
      >>> )

      The according table with four columns [a, a2, b, c] is filled with the following rows:

      >>> [
      >>>     { a:1, a2:2, b:1, c:'cat' },
      >>>     { a:1, a2:2, b:1, c:'dog' },
      >>>     { a:1, a2:2, b:2, c:'cat' },
      >>>     { a:1, a2:2, b:2, c:'dog' },
      >>>     { a:2, a2:4, b:1, c:'cat' },
      >>>     { a:2, a2:4, b:1, c:'dog' },
      >>>     { a:2, a2:4, b:2, c:'cat' },
      >>>     { a:2, a2:4, b:2, c:'dog' }
      >>> ]

      :param fixed_parameter_combinations: List of predefined parameter combinations (each of type dict).
              Defaults to None.
      :type fixed_parameter_combinations: List[dict], optional
      :param parameters: Dictionary of parameters and their lists of possible values. Defaults to None.
      :type parameters: dict, optional
      :raises ParameterCombinationError: If any parameter of the combinations (rows) does not match the keyfields
          from the experiment configuration.


   .. py:method:: fill_table_from_config() -> None

      Adds rows to the database table based on the experiment configuration file.

      First the existence of the database table is checked. If it does not exist, the database table is created
      based on the information from the experiment configuration file the `PyExperimenter` has been initialized
      with.

      Afterwards, the database table is filled. To this end, the cartesian product of all `keyfields` from the
      experiment configuration file is build, where each combination will make up a row in the database table.
      Note that only rows are added whose parameter combinations do not already exist in the table. For each
      added row the status is set to 'created'. If the `keyfield` values do not match their respective types an
      error is raised.


   .. py:method:: fill_table_with_rows(rows: List[dict]) -> None

      Adds rows to the database table based on the given list of `rows`.

      First the existence of the database table is checked. If it does not exist, the database table is created
      based on the information from the experiment configuration file the `PyExperimenter` has been initialized with.

      Afterwards, the database table is filled with the list of `rows`. Note that only rows are added whose
      parameter combinations do not already exist in the table. For each added row the status will is to 'created'.
      If any parameter of `rows` does not match the keyfields from the experiment configuration, an error is
      raised.

      :param rows: A list of rows, where each entry is made up of a dict containing a key-value-pair for each
          `keyfield` of the experiment configuration file.
      :type rows: List[dict]
      :raises ValueError: If any key of any row in `rows` does not match the `keyfields` from the experiment
          configuration file


   .. py:method:: execute(experiment_function: Callable[[Dict, Dict, py_experimenter.result_processor.ResultProcessor], None], max_experiments: int = -1) -> None

      Pulls open experiments from the database table and executes them.

      First as many processes are created and started as specified with `n_jobs` in the experiment configuration file.
      If `n_jobs` is not given, a single process is created. Then two different scenarios are possible.

      If max_experiments == -1, each process is a worker and continuously starts to execute the next open experiment
      until there is no open experiment left in the database table.
      If max_experiments != -1, we generate `max_experiments` jobs to execute experimetns and distribute them to the
      worker processes.

      After pulling an experiment, `experiment_function` is executed with keyfield values of the pulled open
      experiment and the experiments status is set to `running`. Results can be continuously written to the database
      during the execution via `ResultProcessor` that is given as parameter to `experiment_function`. If the execution
      was successful, the status of the corresponding experiment is set to `done`. Otherwise, if an error occurred
      during the execution, the status is changed to  `error` and the raised error is logged to the database table.

      Note that only errors raised within `experiment_function` are logged in to the database table. Therefore all
      errors raised before or after the execution of `experiment_function` are logged according to the local
      logging configuration and do not appear in the table.

      :param experiment_function: The function that should be executed with the different parametrizations.
      :type experiment_function: Callable[[Dict, Dict, ResultProcessor], None]
      :param max_experiments: The number of experiments to be executed by this `PyExperimenter`. If all experiments
          should be executed, set this to `-1`. Defaults to `-1`.
      :type max_experiments: int, optional
      :raises InvalidValuesInConfiguration: If any value of the experiment parameters is of wrong data type.


   .. py:method:: _worker(experiment_function: Callable[[Dict, Dict, py_experimenter.result_processor.ResultProcessor], None]) -> None

      Worker that repeatedly pulls open experiments from the database table and executes them.
      :param experiment_function: The function that should be executed with the different parametrizations.
      :type experiment_function: Callable[[Dict, Dict, ResultProcessor], None]
      :param random_order: Indicates whether the experiments to be executed are chosen consecutively by its experiment 
          ID (`False`) or in a randomized fashion (`True`). Defaults to `False`.
      :type random_order: bool, optional


   .. py:method:: _execution_worker(experiment_function: Callable[[Dict, Dict, py_experimenter.result_processor.ResultProcessor], None]) -> None

      Worker that repeatedly pulls open experiments from the database table and executes them.

      :param experiment_function: The function that should be executed with the different parametrizations.
      :type experiment_function: Callable[[Dict, Dict, ResultProcessor], None]
      :param random_order: Indicates whether the experiments to be executed are chosen consecutively by its experiment 
          ID (`False`) or in a randomized fashion (`True`). Defaults to `False`.
      :type random_order: bool, optional


   .. py:method:: _execution_wrapper(experiment_function: Callable[[dict, dict, py_experimenter.result_processor.ResultProcessor], None]) -> None

      Executes the given `experiment_function` on one open experiment. To that end, one of the open experiments is pulled
      from the database table. Then `experiment_function` is executed on the keyfield values of the pulled experiment. 

      Thereby, the status of the experiment is continuously updated. The experiment can have the following states:

      * `running` when the experiment has been pulled from the database table, which will be executed directly afterwards.
      * `error` if an exception was raised during the execution of the experiment.
      * `done` if the execution of the experiment has finished successfully.

      Errors raised during the execution of `experiment_function` are logged to the `error` column in the database table. 
      Note that only errors raised within `experiment_function` are logged in to the database table. Therefore all errors 
      raised before or after the execution of `experiment_function` are logged according to the local logging configuration 
      and do not appear in the table.

      :param experiment_function: The function that should be executed with the different parametrizations.
      :type experiment_function: Callable[[dict, dict, ResultProcessor], None]
      :raises NoExperimentsLeftError: If there are no experiments left to be executed.
      :raises DatabaseConnectionError: If an error occurred during the connection to the database.


   .. py:method:: reset_experiments(*states: str) -> None

      Deletes the experiments of the database table having the given `status`. Afterwards, all rows that have been 
      deleted from the database table are added to the table again featuring `created` as a status. Experiments 
      to reset can be selected based on the following status definition: 

      :param status: The status of experiments that should be reset. Either `created`, `running`, `error`, `done`, or `all`.
          Note that `states` is a variable length argument, so multiple states can be given as a list.        
         :type status: str


   .. py:method:: delete_table() -> None

      Drops the table defined in the configuration file.


   .. py:method:: get_table() -> pandas.DataFrame

      Returns the database table as `Pandas.DataFrame`. 

      :return: The database table as `Pandas.DataFrame`. 
      :rtype: pd.DataFrame



